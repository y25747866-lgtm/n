/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for user data and their associated products and subscriptions.
 * It provides public read access to trending topics while restricting write access to administrators only.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Only the user can read/write their profile.
 * - /users/{userId}/subscriptions/{subscriptionId}: Stores subscription information for a user. Only the user can access their own subscriptions.
 * - /users/{userId}/products/{productId}: Stores products generated by a user. Includes denormalized 'userId' for authorization.
 * - /trends/{trendId}: Stores trending ideas and topics. Global read access, admin-only write access.
 * - /trending_topics/{topicId}: Stores usage counts for topics. Publicly readable, writable by any authenticated user for incrementing counts.
 * - /roles_admin/{userId}: Collection to store admin roles. Existence of a document grants admin privileges.
 *
 * Key Security Decisions:
 * - User listing is disabled for privacy.
 * - Trending topics are publicly readable but only modifiable by admins.
 * - Subscriptions and Products are secured under the user's path and are only accessible by that user.
 * - Topic usage counts can be updated by any authenticated user to allow for real-time trend tracking.
 *
 * Denormalization for Authorization:
 * - The 'Product' entity includes a 'userId' field, denormalizing the user relationship. This avoids costly `get()` calls in security rules when validating ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) - Authenticated user can create their own profile if the userId matches their auth UID.
     * @allow (get, update, delete) - Authenticated user can read, update, and delete their own profile.
     * @deny (create) - An unauthenticated user cannot create a profile.
     * @deny (update, delete) - A different user cannot modify another user's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isLoggedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow create: if isLoggedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not allowed
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to user subscriptions.
     * @path /users/{userId}/subscriptions/{subscriptionId}
     * @allow (create) - Authenticated user can create a subscription for themselves if the userId matches their auth UID.
     * @allow (get, update, delete) - Authenticated user can read, update, and delete their own subscription.
     * @deny (create) - An unauthenticated user cannot create a subscription.
     * @deny (update, delete) - A different user cannot modify another user's subscription.
     * @principle Enforces document ownership for user subscriptions.
     */
    match /users/{userId}/subscriptions/{subscriptionId} {
      function isLoggedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow create: if isLoggedIn() && isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to user-generated products.
     * @path /users/{userId}/products/{productId}
     * @allow (create) - Authenticated user can create a product for themselves if the userId matches their auth UID.
     * @allow (get, update, delete) - Authenticated user can read, update, and delete their own product.
     * @deny (create) - An unauthenticated user cannot create a product.
     * @deny (update, delete) - A different user cannot modify another user's product.
     * @principle Enforces document ownership for user-generated products.
     */
    match /users/{userId}/products/{productId} {
      function isLoggedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

       function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow create: if isLoggedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to trending topics.
     * @path /trends/{trendId}
     * @allow (get, list) - Any user can read trending topics.
     * @allow (create, update, delete) - Only administrators can create, update, or delete trending topics.
     * @deny (create, update, delete) - Non-administrators cannot modify trending topics.
     * @principle Allows public read access but restricts write access to administrators.
     */
    match /trends/{trendId} {
      function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      }

      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages admin roles. The existence of a document for a user ID grants admin privileges.
     * @path /roles_admin/{userId}
     * @allow (create) - Only a user with an existing admin role can create a new admin role.
     * @allow (get) - Any authenticated user can check if a user has an admin role.
     * @deny (create, update, delete) - Non-administrators cannot grant admin privileges.
     * @principle DBAC (Database-Based Access Control): Admin roles are managed through the database.
     */
    match /roles_admin/{userId} {
      function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      }
      function isLoggedIn() {
        return request.auth != null;
      }

      allow create: if isAdmin();
      allow get: if isLoggedIn();
      allow list: if false; // Prevent listing of admin roles
      allow update: if false;
      allow delete: if isAdmin() && resource != null;
    }

     /**
     * @description Controls access to topic usage counts.
     * @path /trending_topics/{topicId}
     * @allow (read) - Public read access for all users.
     * @allow (write) - Authenticated users can create or update usage counts.
     * @principle Allows community-driven trend tracking.
     */
    match /trending_topics/{topicId} {
        allow read: if true;
        allow write: if request.auth != null;
        allow delete: if false; // To prevent tampering
    }
  }
}
